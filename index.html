<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2D Temple Run Style Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #87ceeb;
      font-family: sans-serif;
      user-select: none;
    }
    #gameCanvas {
      background: #70c5ce;
      display: block;
      margin: 0 auto;
      border: 2px solid #333;
      background-image: linear-gradient(to bottom, #7ec850 40%, #4a7023 100%);
    }
    #score {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 24px;
      color: white;
      text-shadow: 2px 2px 4px #000;
    }
    #gameOverScreen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      font-size: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      display: none;
    }
    button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 20px;
      cursor: pointer;
    }
  </style>
</head>
<body>

<div id="score">Score: 0</div>
<canvas id="gameCanvas" width="400" height="600"></canvas>

<div id="gameOverScreen">
  Game Over<br/>
  <button onclick="startGame()">Restart</button>
</div>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const gameOverScreen = document.getElementById('gameOverScreen');

  let player = {
    x: 180,
    y: 500,
    width: 40,
    height: 60,
    color: '#ff4500',
    speedX: 7
  };

  let obstacles = [];
  let coins = [];

  let gameSpeed = 5;
  let score = 0;
  let frameCount = 0;
  let gameRunning = false;

  function drawRect(obj) {
    ctx.fillStyle = obj.color;
    ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
  }

  function drawCircle(obj) {
    ctx.fillStyle = obj.color;
    ctx.beginPath();
    ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
    ctx.fill();
  }

  function startGame() {
    obstacles = [];
    coins = [];
    score = 0;
    gameSpeed = 5;
    frameCount = 0;
    player.x = 180;
    gameRunning = true;
    gameOverScreen.style.display = 'none';
    requestAnimationFrame(gameLoop);
  }

  function gameOver() {
    gameRunning = false;
    gameOverScreen.style.display = 'flex';
  }

  // Controls (touch or keyboard)
  let keys = {};
  window.addEventListener('keydown', (e) => {
    keys[e.key] = true;
  });
  window.addEventListener('keyup', (e) => {
    keys[e.key] = false;
  });

  canvas.addEventListener('touchstart', function(e) {
    const touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
    if (touchX < canvas.width / 2) {
      keys['ArrowLeft'] = true;
      setTimeout(() => keys['ArrowLeft'] = false, 100);
    } else {
      keys['ArrowRight'] = true;
      setTimeout(() => keys['ArrowRight'] = false, 100);
    }
  });

  function updatePlayer() {
    if (keys['ArrowLeft']) {
      player.x -= player.speedX;
      if (player.x < 0) player.x = 0;
    }
    if (keys['ArrowRight']) {
      player.x += player.speedX;
      if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
    }
  }

  function updateObstacles() {
    for (let i = obstacles.length - 1; i >= 0; i--) {
      obstacles[i].y += gameSpeed;
      if (obstacles[i].y > canvas.height) {
        obstacles.splice(i, 1);
        score += 5; // Score for avoiding obstacle
      } else if (checkCollision(player, obstacles[i])) {
        gameOver();
      }
    }
  }

  function updateCoins() {
    for (let i = coins.length - 1; i >= 0; i--) {
      coins[i].y += gameSpeed;
      if (coins[i].y > canvas.height) {
        coins.splice(i, 1);
      } else if (circleRectCollision(coins[i], player)) {
        score += 10;
        coins.splice(i, 1);
      }
    }
  }

  function checkCollision(rect1, rect2) {
    return !(rect1.x > rect2.x + rect2.width || 
             rect1.x + rect1.width < rect2.x || 
             rect1.y > rect2.y + rect2.height ||
             rect1.y + rect1.height < rect2.y);
  }

  function circleRectCollision(circle, rect) {
    // Find closest point to circle center within rect
    let closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
    let closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));

    let dx = circle.x - closestX;
    let dy = circle.y - closestY;

    return (dx * dx + dy * dy) < (circle.radius * circle.radius);
  }

  function spawnObstaclesAndCoins() {
    if (frameCount % 90 === 0) { // every ~1.5 sec at 60fps
      let obsWidth = 50;
      let obsHeight = 30;
      let obsX = Math.floor(Math.random() * (canvas.width - obsWidth));
      obstacles.push({
        x: obsX,
        y: -obsHeight,
        width: obsWidth,
        height: obsHeight,
        color: '#333'
      });
    }
    if (frameCount % 60 === 0) { // every ~1 sec
      let coinX = Math.floor(Math.random() * (canvas.width - 20)) + 10;
      coins.push({
        x: coinX,
        y: -20,
        radius: 10,
        color: 'yellow'
      });
    }
  }

  function increaseSpeed() {
    if (frameCount % 300 === 0) { // every 5 seconds (assuming 60fps)
      gameSpeed += 0.5;
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw player
    drawRect(player);

    // Draw obstacles
    obstacles.forEach(drawRect);

    // Draw coins
    coins.forEach(drawCircle);
  }

  function gameLoop() {
    if (!gameRunning) return;

    frameCount++;
    updatePlayer();
    spawnObstaclesAndCoins();
    updateObstacles();
    updateCoins();
    increaseSpeed();

    draw();
    scoreEl.textContent = 'Score: ' + score;

    requestAnimationFrame(gameLoop);
  }

  // Start game on load
  startGame();
</script>

</body>
</html>
